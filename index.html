<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Pupil Trace Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.8.0/simple-statistics.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #1e3c72;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        .tab:hover {
            color: #1e3c72;
            background: rgba(30, 60, 114, 0.05);
        }
        .tab.active {
            color: #1e3c72;
            border-bottom-color: #1e3c72;
            font-weight: 600;
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }
        .tab-content.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 15px;
            color: white;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            opacity: 0.9;
            font-weight: 400;
        }
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            margin: 5px 0;
        }
        .stat-detail {
            font-size: 12px;
            opacity: 0.8;
        }
        .chart-container {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }
        .analysis-section {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #1e3c72;
        }
        .analysis-section h2 {
            color: #1e3c72;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .analysis-section h3 {
            color: #2a5298;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        .load-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 18px;
            margin: 20px auto;
            display: block;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        .load-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.6);
        }
        .stimulus-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }
        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .metric-row:last-child {
            border-bottom: none;
        }
        .metric-label {
            font-weight: 600;
            color: #555;
        }
        .metric-value {
            color: #1e3c72;
            font-weight: 700;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        th {
            background: #1e3c72;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        tr:hover {
            background: #f5f5f5;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            color: #856404;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            color: #0c5460;
        }
        #fileInput {
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Comprehensive Pupil Response Analysis</h1>
        
        <button class="load-button" onclick="loadFile()">üìä Load Excel File</button>
        <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="handleFile(event)">
        
        <div id="loading" style="display:none; text-align:center; padding:20px;">
            <p>Loading and analyzing data...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div id="results" style="display:none;">
            <div class="tabs">
                <button class="tab active" onclick="showTab('overview')">Overview</button>
                <button class="tab" onclick="showTab('temporal')">Temporal Analysis</button>
                <button class="tab" onclick="showTab('response')">Response Dynamics</button>
                <button class="tab" onclick="showTab('latency')">Latency Analysis</button>
                <button class="tab" onclick="showTab('recovery')">Recovery Analysis</button>
                <button class="tab" onclick="showTab('frequency')">Frequency Domain</button>
                <button class="tab" onclick="showTab('comparison')">Stimulus Comparison</button>
                <button class="tab" onclick="showTab('advanced')">Advanced Metrics</button>
            </div>
            
            <div id="overview" class="tab-content active">
                <div class="stats-grid" id="statsGrid"></div>
                <div class="chart-container">
                    <h2>üìà Pupil Size Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="mainChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="temporal" class="tab-content">
                <div class="analysis-section">
                    <h2>‚è±Ô∏è Temporal Analysis</h2>
                    <div id="temporalAnalysis"></div>
                    <div class="chart-wrapper">
                        <canvas id="velocityChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="response" class="tab-content">
                <div class="analysis-section">
                    <h2>üí° Response Dynamics</h2>
                    <div id="responseDynamics"></div>
                    <div class="chart-wrapper">
                        <canvas id="responseChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="latency" class="tab-content">
                <div class="analysis-section">
                    <h2>‚ö° Latency Analysis</h2>
                    <div id="latencyAnalysis"></div>
                    <div class="chart-wrapper">
                        <canvas id="latencyChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="recovery" class="tab-content">
                <div class="analysis-section">
                    <h2>üîÑ Recovery Analysis</h2>
                    <div id="recoveryAnalysis"></div>
                    <div class="chart-wrapper">
                        <canvas id="recoveryChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="frequency" class="tab-content">
                <div class="analysis-section">
                    <h2>üìä Frequency Domain Analysis</h2>
                    <div id="frequencyAnalysis"></div>
                    <div class="chart-wrapper">
                        <canvas id="spectrumChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="comparison" class="tab-content">
                <div class="analysis-section">
                    <h2>üîç Stimulus Comparison</h2>
                    <div id="comparisonAnalysis"></div>
                    <div class="chart-wrapper">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="advanced" class="tab-content">
                <div class="analysis-section">
                    <h2>üßÆ Advanced Metrics</h2>
                    <div id="advancedMetrics"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let analysisData = [];
        let charts = {};
        let stimulusGroups = [];

        async function loadFile() {
            try {
                const response = await window.fs.readFile('raw trace data.xlsx');
                const workbook = XLSX.read(response, { cellDates: true });
                processWorkbook(workbook);
            } catch (error) {
                document.getElementById('fileInput').click();
            }
        }

        function handleFile(e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                processWorkbook(workbook);
            };
            
            reader.readAsArrayBuffer(file);
        }

        function processWorkbook(workbook) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('progressFill').style.width = '20%';
            
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
            
            // Parse data
            analysisData = [];
            const dataRows = data.slice(1);
            
            dataRows.forEach((row, idx) => {
                if (row[1] !== null && row[1] !== undefined) {
                    analysisData.push({
                        index: idx,
                        id: row[0],
                        pupilSize: parseFloat(row[1]),
                        timestamp: parseInt(row[2]),
                        frame: parseInt(row[3]),
                        actualTrigger: row[4],
                        theoreticalTrigger: row[8],
                        relativeTime: (row[2] - dataRows[0][2]) / 1000
                    });
                }
            });
            
            document.getElementById('progressFill').style.width = '40%';
            
            // Perform comprehensive analysis
            performAllAnalyses();
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('results').style.display = 'block';
        }

        function performAllAnalyses() {
            // Calculate derivatives
            calculateDerivatives();
            document.getElementById('progressFill').style.width = '50%';
            
            // Find stimulus groups
            findStimulusGroups();
            document.getElementById('progressFill').style.width = '60%';
            
            // Display basic stats
            displayBasicStats();
            document.getElementById('progressFill').style.width = '70%';
            
            // Create all visualizations
            createMainChart();
            document.getElementById('progressFill').style.width = '80%';
            
            // Perform all analyses
            performTemporalAnalysis();
            performResponseDynamics();
            performLatencyAnalysis();
            performRecoveryAnalysis();
            performFrequencyAnalysis();
            performComparison();
            performAdvancedAnalysis();
            
            document.getElementById('progressFill').style.width = '100%';
        }

        function calculateDerivatives() {
            // Calculate velocity (first derivative) and acceleration (second derivative)
            for (let i = 1; i < analysisData.length - 1; i++) {
                const dt = analysisData[i].relativeTime - analysisData[i-1].relativeTime;
                if (dt > 0) {
                    analysisData[i].velocity = (analysisData[i].pupilSize - analysisData[i-1].pupilSize) / dt;
                    
                    if (i > 1 && analysisData[i-1].velocity !== undefined) {
                        analysisData[i].acceleration = (analysisData[i].velocity - analysisData[i-1].velocity) / dt;
                    }
                }
            }
        }

        function findStimulusGroups() {
            stimulusGroups = [];
            const stimData = analysisData.filter(d => d.actualTrigger === 'Stimulus');
            
            if (stimData.length === 0) return;
            
            let currentGroup = {
                startIdx: stimData[0].index,
                startTime: stimData[0].timestamp,
                data: [stimData[0]]
            };
            
            for (let i = 1; i < stimData.length; i++) {
                const timeDiff = stimData[i].timestamp - stimData[i-1].timestamp;
                if (timeDiff > 100) {
                    currentGroup.endIdx = stimData[i-1].index;
                    currentGroup.endTime = stimData[i-1].timestamp;
                    stimulusGroups.push(currentGroup);
                    
                    currentGroup = {
                        startIdx: stimData[i].index,
                        startTime: stimData[i].timestamp,
                        data: [stimData[i]]
                    };
                } else {
                    currentGroup.data.push(stimData[i]);
                }
            }
            
            currentGroup.endIdx = stimData[stimData.length - 1].index;
            currentGroup.endTime = stimData[stimData.length - 1].timestamp;
            stimulusGroups.push(currentGroup);
        }

        function displayBasicStats() {
            const pupilSizes = analysisData.map(d => d.pupilSize);
            const stats = {
                count: pupilSizes.length,
                mean: ss.mean(pupilSizes),
                median: ss.median(pupilSizes),
                stdDev: ss.standardDeviation(pupilSizes),
                min: ss.min(pupilSizes),
                max: ss.max(pupilSizes),
                range: ss.max(pupilSizes) - ss.min(pupilSizes),
                iqr: ss.interquartileRange(pupilSizes),
                cv: (ss.standardDeviation(pupilSizes) / ss.mean(pupilSizes)) * 100,
                duration: analysisData[analysisData.length - 1].relativeTime
            };
            
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>Total Samples</h3>
                    <div class="stat-value">${stats.count}</div>
                    <div class="stat-detail">${(stats.count / stats.duration).toFixed(1)} Hz</div>
                </div>
                <div class="stat-card">
                    <h3>Duration</h3>
                    <div class="stat-value">${stats.duration.toFixed(1)}s</div>
                    <div class="stat-detail">${stimulusGroups.length} stimuli</div>
                </div>
                <div class="stat-card">
                    <h3>Mean Pupil Size</h3>
                    <div class="stat-value">${stats.mean.toFixed(3)}mm</div>
                    <div class="stat-detail">Median: ${stats.median.toFixed(3)}mm</div>
                </div>
                <div class="stat-card">
                    <h3>Variability</h3>
                    <div class="stat-value">${stats.stdDev.toFixed(3)}mm</div>
                    <div class="stat-detail">CV: ${stats.cv.toFixed(1)}%</div>
                </div>
                <div class="stat-card">
                    <h3>Range</h3>
                    <div class="stat-value">${stats.range.toFixed(3)}mm</div>
                    <div class="stat-detail">${stats.min.toFixed(3)} - ${stats.max.toFixed(3)}</div>
                </div>
                <div class="stat-card">
                    <h3>IQR</h3>
                    <div class="stat-value">${stats.iqr.toFixed(3)}mm</div>
                    <div class="stat-detail">Robust spread</div>
                </div>
            `;
        }

        function createMainChart() {
            const ctx = document.getElementById('mainChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.main) charts.main.destroy();
            
            // Prepare datasets
            const datasets = [{
                label: 'Pupil Size',
                data: analysisData.map(d => ({ x: d.relativeTime, y: d.pupilSize })),
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.1
            }];
            
            // Add stimulus markers as vertical lines
            const annotations = {};
            stimulusGroups.forEach((group, idx) => {
                const startTime = (group.startTime - analysisData[0].timestamp) / 1000;
                const endTime = (group.endTime - analysisData[0].timestamp) / 1000;
                
                annotations[`stim${idx}start`] = {
                    type: 'line',
                    xMin: startTime,
                    xMax: startTime,
                    borderColor: 'rgb(255, 99, 132)',
                    borderWidth: 2,
                    label: {
                        content: `Stim ${idx + 1}`,
                        enabled: true,
                        position: 'start'
                    }
                };
                
                annotations[`stim${idx}box`] = {
                    type: 'box',
                    xMin: startTime,
                    xMax: endTime,
                    backgroundColor: 'rgba(255, 99, 132, 0.25)'
                };
            });
            
            charts.main = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Pupil Size Time Series with Stimulus Markers',
                            font: { size: 16 }
                        },
                        annotation: {
                            annotations
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Pupil Size (mm)'
                            }
                        }
                    }
                }
            });
        }

        function performTemporalAnalysis() {
            // Calculate temporal statistics
            const velocities = analysisData.filter(d => d.velocity !== undefined).map(d => d.velocity);
            const accelerations = analysisData.filter(d => d.acceleration !== undefined).map(d => d.acceleration);
            
            let html = '<h3>Velocity Analysis</h3>';
            html += '<div class="info">';
            html += `<p><strong>Maximum Constriction Velocity:</strong> ${Math.min(...velocities).toFixed(3)} mm/s</p>`;
            html += `<p><strong>Maximum Dilation Velocity:</strong> ${Math.max(...velocities).toFixed(3)} mm/s</p>`;
            html += `<p><strong>Mean Absolute Velocity:</strong> ${ss.mean(velocities.map(Math.abs)).toFixed(3)} mm/s</p>`;
            html += '</div>';
            
            html += '<h3>Acceleration Analysis</h3>';
            html += '<div class="info">';
            html += `<p><strong>Maximum Acceleration:</strong> ${Math.max(...accelerations).toFixed(3)} mm/s¬≤</p>`;
            html += `<p><strong>Maximum Deceleration:</strong> ${Math.min(...accelerations).toFixed(3)} mm/s¬≤</p>`;
            html += '</div>';
            
            // Find rapid changes
            const rapidChanges = [];
            for (let i = 1; i < analysisData.length; i++) {
                if (analysisData[i].velocity && Math.abs(analysisData[i].velocity) > 2) {
                    rapidChanges.push({
                        time: analysisData[i].relativeTime,
                        velocity: analysisData[i].velocity,
                        type: analysisData[i].velocity < 0 ? 'constriction' : 'dilation'
                    });
                }
            }
            
            html += '<h3>Rapid Changes Detected</h3>';
            html += `<p>Found ${rapidChanges.length} rapid changes (|velocity| > 2 mm/s)</p>`;
            
            document.getElementById('temporalAnalysis').innerHTML = html;
            
            // Create velocity chart
            const ctx = document.getElementById('velocityChart').getContext('2d');
            if (charts.velocity) charts.velocity.destroy();
            
            charts.velocity = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Pupil Velocity',
                        data: analysisData.filter(d => d.velocity !== undefined).map(d => ({ 
                            x: d.relativeTime, 
                            y: d.velocity 
                        })),
                        borderColor: 'rgb(153, 102, 255)',
                        backgroundColor: 'rgba(153, 102, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Pupil Size Velocity (First Derivative)'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Time (s)' }
                        },
                        y: {
                            title: { display: true, text: 'Velocity (mm/s)' }
                        }
                    }
                }
            });
        }

        function performResponseDynamics() {
            let html = '<h3>Individual Stimulus Responses</h3>';
            
            const allResponses = [];
            
            stimulusGroups.forEach((group, idx) => {
                const startIdx = group.startIdx;
                const endIdx = group.endIdx;
                
                // Get baseline (1s before stimulus)
                const baselineData = analysisData.filter(d => 
                    d.timestamp >= (group.startTime - 1000) && 
                    d.timestamp < group.startTime
                ).map(d => d.pupilSize);
                
                // Get response data (during + 2s after)
                const responseData = analysisData.filter(d => 
                    d.timestamp >= group.startTime && 
                    d.timestamp <= (group.endTime + 2000)
                );
                
                if (baselineData.length > 0 && responseData.length > 0) {
                    const baseline = ss.mean(baselineData);
                    const minResponse = Math.min(...responseData.map(d => d.pupilSize));
                    const amplitude = baseline - minResponse;
                    const percentChange = (amplitude / baseline) * 100;
                    
                    // Find time to minimum
                    const minIdx = responseData.findIndex(d => d.pupilSize === minResponse);
                    const timeToMin = responseData[minIdx].relativeTime - (group.startTime - analysisData[0].timestamp) / 1000;
                    
                    html += `<div class="stimulus-card">`;
                    html += `<h4>Stimulus ${idx + 1}</h4>`;
                    html += `<div class="metric-row">`;
                    html += `<span class="metric-label">Baseline:</span>`;
                    html += `<span class="metric-value">${baseline.toFixed(3)} mm</span>`;
                    html += `</div>`;
                    html += `<div class="metric-row">`;
                    html += `<span class="metric-label">Minimum:</span>`;
                    html += `<span class="metric-value">${minResponse.toFixed(3)} mm</span>`;
                    html += `</div>`;
                    html += `<div class="metric-row">`;
                    html += `<span class="metric-label">Amplitude:</span>`;
                    html += `<span class="metric-value">${amplitude.toFixed(3)} mm (${percentChange.toFixed(1)}%)</span>`;
                    html += `</div>`;
                    html += `<div class="metric-row">`;
                    html += `<span class="metric-label">Time to Min:</span>`;
                    html += `<span class="metric-value">${timeToMin.toFixed(2)} s</span>`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    allResponses.push({
                        stimulus: idx + 1,
                        baseline,
                        minimum: minResponse,
                        amplitude,
                        percentChange,
                        timeToMin,
                        data: responseData
                    });
                }
            });
            
            // Summary statistics across all responses
            if (allResponses.length > 0) {
                html += '<h3>Response Summary Statistics</h3>';
                html += '<div class="info">';
                html += `<p><strong>Mean Amplitude:</strong> ${ss.mean(allResponses.map(r => r.amplitude)).toFixed(3)} mm</p>`;
                html += `<p><strong>Mean % Change:</strong> ${ss.mean(allResponses.map(r => r.percentChange)).toFixed(1)}%</p>`;
                html += `<p><strong>Mean Time to Min:</strong> ${ss.mean(allResponses.map(r => r.timeToMin)).toFixed(2)} s</p>`;
                html += '</div>';
            }
            
            document.getElementById('responseDynamics').innerHTML = html;
            
            // Create response overlay chart
            const ctx = document.getElementById('responseChart').getContext('2d');
            if (charts.response) charts.response.destroy();
            
            // Normalize responses to overlay them
            const datasets = allResponses.map((resp, idx) => {
                const normalizedData = resp.data.map(d => ({
                    x: d.relativeTime - (stimulusGroups[idx].startTime - analysisData[0].timestamp) / 1000,
                    y: (d.pupilSize - resp.baseline) / resp.baseline * 100
                }));
                
                return {
                    label: `Stimulus ${idx + 1}`,
                    data: normalizedData,
                    borderColor: `hsl(${idx * 90}, 70%, 50%)`,
                    backgroundColor: `hsla(${idx * 90}, 70%, 50%, 0.1)`,
                    borderWidth: 2,
                    pointRadius: 0
                };
            });
            
            charts.response = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Normalized Response Curves (% Change from Baseline)'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Time from Stimulus Onset (s)' }
                        },
                        y: {
                            title: { display: true, text: '% Change from Baseline' }
                        }
                    }
                }
            });
        }

        function performLatencyAnalysis() {
            let html = '<h3>Response Latencies</h3>';
            
            const latencies = [];
            
            stimulusGroups.forEach((group, idx) => {
                // Find first significant change after stimulus
                const baselineStart = group.startIdx - 30;
                const baselineEnd = group.startIdx;
                
                if (baselineStart >= 0) {
                    const baselineData = analysisData.slice(baselineStart, baselineEnd).map(d => d.pupilSize);
                    const baselineMean = ss.mean(baselineData);
                    const baselineStd = ss.standardDeviation(baselineData);
                    const threshold = baselineMean - 2 * baselineStd;
                    
                    // Find first point below threshold
                    let latencyIdx = -1;
                    for (let i = group.startIdx; i < Math.min(group.startIdx + 50, analysisData.length); i++) {
                        if (analysisData[i].pupilSize < threshold) {
                            latencyIdx = i;
                            break;
                        }
                    }
                    
                    if (latencyIdx > -1) {
                        const latency = (analysisData[latencyIdx].timestamp - group.startTime);
                        latencies.push({
                            stimulus: idx + 1,
                            latency,
                            threshold
                        });
                        
                        html += `<div class="metric-row">`;
                        html += `<span class="metric-label">Stimulus ${idx + 1} Latency:</span>`;
                        html += `<span class="metric-value">${latency} ms</span>`;
                        html += `</div>`;
                    }
                }
            });
            
            if (latencies.length > 0) {
                html += '<h3>Latency Statistics</h3>';
                html += '<div class="info">';
                html += `<p><strong>Mean Latency:</strong> ${ss.mean(latencies.map(l => l.latency)).toFixed(0)} ms</p>`;
                html += `<p><strong>Std Dev:</strong> ${ss.standardDeviation(latencies.map(l => l.latency)).toFixed(0)} ms</p>`;
                html += `<p><strong>Range:</strong> ${Math.min(...latencies.map(l => l.latency))} - ${Math.max(...latencies.map(l => l.latency))} ms</p>`;
                html += '</div>';
            }
            
            document.getElementById('latencyAnalysis').innerHTML = html;
            
            // Create latency visualization
            const ctx = document.getElementById('latencyChart').getContext('2d');
            if (charts.latency) charts.latency.destroy();
            
            charts.latency = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: latencies.map(l => `Stimulus ${l.stimulus}`),
                    datasets: [{
                        label: 'Response Latency',
                        data: latencies.map(l => l.latency),
                        backgroundColor: 'rgba(255, 159, 64, 0.8)',
                        borderColor: 'rgb(255, 159, 64)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Response Latencies by Stimulus'
                        }
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Latency (ms)' }
                        }
                    }
                }
            });
        }

        function performRecoveryAnalysis() {
            let html = '<h3>Recovery Dynamics</h3>';
            
            const recoveryMetrics = [];
            
            stimulusGroups.forEach((group, idx) => {
                // Get baseline before stimulus
                const baselineData = analysisData.filter(d => 
                    d.timestamp >= (group.startTime - 1000) && 
                    d.timestamp < group.startTime
                ).map(d => d.pupilSize);
                
                if (baselineData.length === 0) return;
                
                const baseline = ss.mean(baselineData);
                const recoveryThreshold = baseline * 0.95; // 95% recovery
                
                // Find recovery time
                let recoveryTime = null;
                const postStimData = analysisData.filter(d => d.timestamp > group.endTime);
                
                for (let i = 0; i < postStimData.length; i++) {
                    if (postStimData[i].pupilSize >= recoveryThreshold) {
                        recoveryTime = postStimData[i].timestamp - group.endTime;
                        break;
                    }
                }
                
                if (recoveryTime !== null) {
                    recoveryMetrics.push({
                        stimulus: idx + 1,
                        recoveryTime: recoveryTime / 1000,
                        baseline
                    });
                }
            });
            
            if (recoveryMetrics.length > 0) {
                html += '<table>';
                html += '<tr><th>Stimulus</th><th>Baseline (mm)</th><th>95% Recovery Time (s)</th></tr>';
                recoveryMetrics.forEach(m => {
                    html += `<tr>`;
                    html += `<td>Stimulus ${m.stimulus}</td>`;
                    html += `<td>${m.baseline.toFixed(3)}</td>`;
                    html += `<td>${m.recoveryTime.toFixed(2)}</td>`;
                    html += `</tr>`;
                });
                html += '</table>';
                
                html += '<h3>Recovery Statistics</h3>';
                html += '<div class="info">';
                html += `<p><strong>Mean Recovery Time:</strong> ${ss.mean(recoveryMetrics.map(r => r.recoveryTime)).toFixed(2)} s</p>`;
                html += `<p><strong>Fastest Recovery:</strong> ${Math.min(...recoveryMetrics.map(r => r.recoveryTime)).toFixed(2)} s</p>`;
                html += `<p><strong>Slowest Recovery:</strong> ${Math.max(...recoveryMetrics.map(r => r.recoveryTime)).toFixed(2)} s</p>`;
                html += '</div>';
            }
            
            document.getElementById('recoveryAnalysis').innerHTML = html;
            
            // Create recovery curves
            const ctx = document.getElementById('recoveryChart').getContext('2d');
            if (charts.recovery) charts.recovery.destroy();
            
            const datasets = [];
            stimulusGroups.forEach((group, idx) => {
                const recoveryData = analysisData.filter(d => 
                    d.timestamp >= group.endTime && 
                    d.timestamp <= group.endTime + 5000
                );
                
                if (recoveryData.length > 0) {
                    datasets.push({
                        label: `Post-Stimulus ${idx + 1}`,
                        data: recoveryData.map(d => ({
                            x: (d.timestamp - group.endTime) / 1000,
                            y: d.pupilSize
                        })),
                        borderColor: `hsl(${idx * 90}, 70%, 50%)`,
                        borderWidth: 2,
                        pointRadius: 0
                    });
                }
            });
            
            charts.recovery = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Recovery Curves After Stimulus Offset'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Time After Stimulus (s)' }
                        },
                        y: {
                            title: { display: true, text: 'Pupil Size (mm)' }
                        }
                    }
                }
            });
        }

        function performFrequencyAnalysis() {
            let html = '<h3>Frequency Domain Analysis</h3>';
            
            // Prepare data for FFT
            const pupilSizes = analysisData.map(d => d.pupilSize);
            const n = pupilSizes.length;
            
            // Simple FFT implementation for power spectrum
            const fft = new FFT(n);
            const spectrum = fft.forward(pupilSizes);
            
            // Calculate power spectrum
            const powerSpectrum = [];
            const samplingRate = n / analysisData[analysisData.length - 1].relativeTime;
            
            for (let i = 0; i < n/2; i++) {
                const freq = i * samplingRate / n;
                const power = Math.sqrt(spectrum[i*2]**2 + spectrum[i*2+1]**2);
                powerSpectrum.push({ freq, power });
            }
            
            // Find dominant frequencies
            const sortedPower = [...powerSpectrum].sort((a, b) => b.power - a.power);
            const dominantFreqs = sortedPower.slice(0, 5);
            
            html += '<div class="info">';
            html += '<h4>Dominant Frequencies:</h4>';
            dominantFreqs.forEach((f, idx) => {
                html += `<p>${idx + 1}. ${f.freq.toFixed(3)} Hz (Power: ${f.power.toFixed(2)})</p>`;
            });
            html += '</div>';
            
            // Spectral analysis summary
            const totalPower = powerSpectrum.reduce((sum, p) => sum + p.power, 0);
            const lowFreqPower = powerSpectrum.filter(p => p.freq < 0.1).reduce((sum, p) => sum + p.power, 0);
            const midFreqPower = powerSpectrum.filter(p => p.freq >= 0.1 && p.freq < 1).reduce((sum, p) => sum + p.power, 0);
            const highFreqPower = powerSpectrum.filter(p => p.freq >= 1).reduce((sum, p) => sum + p.power, 0);
            
            html += '<h3>Spectral Power Distribution</h3>';
            html += '<div class="info">';
            html += `<p><strong>Low Freq (< 0.1 Hz):</strong> ${(lowFreqPower/totalPower*100).toFixed(1)}%</p>`;
            html += `<p><strong>Mid Freq (0.1-1 Hz):</strong> ${(midFreqPower/totalPower*100).toFixed(1)}%</p>`;
            html += `<p><strong>High Freq (> 1 Hz):</strong> ${(highFreqPower/totalPower*100).toFixed(1)}%</p>`;
            html += '</div>';
            
            document.getElementById('frequencyAnalysis').innerHTML = html;
            
            // Create spectrum chart
            const ctx = document.getElementById('spectrumChart').getContext('2d');
            if (charts.spectrum) charts.spectrum.destroy();
            
            charts.spectrum = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Power Spectrum',
                        data: powerSpectrum.filter(p => p.freq < 5).map(p => ({ x: p.freq, y: p.power })),
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Frequency Spectrum of Pupil Size'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Frequency (Hz)' }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Power (log scale)' }
                        }
                    }
                }
            });
        }

        function performComparison() {
            let html = '<h3>Cross-Stimulus Comparison</h3>';
            
            // Create comparison table
            html += '<table>';
            html += '<tr><th>Metric</th>';
            stimulusGroups.forEach((g, idx) => {
                html += `<th>Stimulus ${idx + 1}</th>`;
            });
            html += '</tr>';
            
            // Comparison metrics
            const metrics = ['Baseline (mm)', 'Minimum (mm)', 'Amplitude (mm)', '% Change', 'Latency (ms)', 'Recovery (s)'];
            const metricData = [];
            
            stimulusGroups.forEach((group, idx) => {
                const baselineData = analysisData.filter(d => 
                    d.timestamp >= (group.startTime - 1000) && 
                    d.timestamp < group.startTime
                ).map(d => d.pupilSize);
                
                const responseData = analysisData.filter(d => 
                    d.timestamp >= group.startTime && 
                    d.timestamp <= (group.endTime + 2000)
                ).map(d => d.pupilSize);
                
                if (baselineData.length > 0 && responseData.length > 0) {
                    const baseline = ss.mean(baselineData);
                    const minimum = Math.min(...responseData);
                    const amplitude = baseline - minimum;
                    const percentChange = (amplitude / baseline) * 100;
                    
                    metricData.push({
                        baseline,
                        minimum,
                        amplitude,
                        percentChange,
                        latency: 'N/A', // Placeholder
                        recovery: 'N/A' // Placeholder
                    });
                }
            });
            
            // Populate table
            ['baseline', 'minimum', 'amplitude', 'percentChange'].forEach((key, keyIdx) => {
                html += '<tr>';
                html += `<td>${metrics[keyIdx]}</td>`;
                metricData.forEach(m => {
                    const value = m[key];
                    html += `<td>${typeof value === 'number' ? value.toFixed(3) : value}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</table>';
            
            // Statistical tests
            if (metricData.length > 1) {
                html += '<h3>Statistical Comparison</h3>';
                html += '<div class="warning">';
                html += '<p>Variability Analysis:</p>';
                
                const amplitudes = metricData.map(m => m.amplitude);
                const cv = (ss.standardDeviation(amplitudes) / ss.mean(amplitudes)) * 100;
                
                html += `<p><strong>Amplitude CV:</strong> ${cv.toFixed(1)}% `;
                html += cv < 10 ? '(Consistent responses)' : cv < 20 ? '(Moderate variability)' : '(High variability)';
                html += '</p>';
                
                html += '</div>';
            }
            
            document.getElementById('comparisonAnalysis').innerHTML = html;
            
            // Create comparison chart
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            if (charts.comparison) charts.comparison.destroy();
            
            charts.comparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: metrics.slice(0, 4),
                    datasets: metricData.map((m, idx) => ({
                        label: `Stimulus ${idx + 1}`,
                        data: [m.baseline, m.minimum, m.amplitude, m.percentChange],
                        backgroundColor: `hsla(${idx * 90}, 70%, 50%, 0.8)`,
                        borderColor: `hsl(${idx * 90}, 70%, 50%)`,
                        borderWidth: 2
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Stimulus Response Comparison'
                        }
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Value' }
                        }
                    }
                }
            });
        }

        function performAdvancedAnalysis() {
            let html = '<h3>Advanced Metrics</h3>';
            
            // Habituation analysis
            const amplitudes = [];
            stimulusGroups.forEach((group, idx) => {
                const baselineData = analysisData.filter(d => 
                    d.timestamp >= (group.startTime - 1000) && 
                    d.timestamp < group.startTime
                ).map(d => d.pupilSize);
                
                const responseData = analysisData.filter(d => 
                    d.timestamp >= group.startTime && 
                    d.timestamp <= (group.endTime + 2000)
                ).map(d => d.pupilSize);
                
                if (baselineData.length > 0 && responseData.length > 0) {
                    const baseline = ss.mean(baselineData);
                    const minimum = Math.min(...responseData);
                    amplitudes.push({
                        stimulus: idx + 1,
                        amplitude: baseline - minimum
                    });
                }
            });
            
            if (amplitudes.length > 2) {
                const xValues = amplitudes.map(a => a.stimulus);
                const yValues = amplitudes.map(a => a.amplitude);
                const regression = ss.linearRegression([xValues, yValues]);
                const regressionLine = ss.linearRegressionLine(regression);
                
                html += '<div class="info">';
                html += '<h4>Habituation Analysis</h4>';
                html += `<p><strong>Slope:</strong> ${regression.m.toFixed(4)} mm/stimulus</p>`;
                html += `<p><strong>Interpretation:</strong> `;
                if (regression.m < -0.05) {
                    html += 'Strong habituation detected';
                } else if (regression.m < -0.01) {
                    html += 'Mild habituation detected';
                } else if (regression.m > 0.01) {
                    html += 'Sensitization detected';
                } else {
                    html += 'No significant habituation';
                }
                html += '</p>';
                html += '</div>';
            }
            
            // Pupillary unrest analysis
            const restPeriods = [];
            let currentRest = [];
            
            for (let i = 0; i < analysisData.length; i++) {
                if (!analysisData[i].actualTrigger) {
                    currentRest.push(analysisData[i].pupilSize);
                } else if (currentRest.length > 30) {
                    restPeriods.push(currentRest);
                    currentRest = [];
                }
            }
            
            if (restPeriods.length > 0) {
                html += '<div class="info">';
                html += '<h4>Pupillary Unrest Index (PUI)</h4>';
                
                restPeriods.forEach((period, idx) => {
                    const pui = ss.standardDeviation(period);
                    html += `<p><strong>Rest Period ${idx + 1}:</strong> ${pui.toFixed(3)} mm</p>`;
                });
                
                html += '</div>';
            }
            
            // Signal quality metrics
            const snr = calculateSNR();
            html += '<div class="info">';
            html += '<h4>Signal Quality Metrics</h4>';
            html += `<p><strong>Signal-to-Noise Ratio:</strong> ${snr.toFixed(1)} dB</p>`;
            html += `<p><strong>Data Completeness:</strong> ${((analysisData.length / (analysisData[analysisData.length-1].frame - analysisData[0].frame)) * 100).toFixed(1)}%</p>`;
            html += '</div>';
            
            document.getElementById('advancedMetrics').innerHTML = html;
        }

        function calculateSNR() {
            // Estimate signal power from stimulus responses
            let signalPower = 0;
            let noisePower = 0;
            
            stimulusGroups.forEach(group => {
                const responseData = analysisData.filter(d => 
                    d.timestamp >= group.startTime && 
                    d.timestamp <= group.endTime
                ).map(d => d.pupilSize);
                
                if (responseData.length > 0) {
                    signalPower += ss.variance(responseData);
                }
            });
            
            // Estimate noise from baseline periods
            const baselineData = analysisData.filter(d => !d.actualTrigger).map(d => d.pupilSize);
            if (baselineData.length > 0) {
                noisePower = ss.variance(baselineData);
            }
            
            return 10 * Math.log10(signalPower / noisePower);
        }

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Simple FFT implementation
        class FFT {
            constructor(size) {
                this.size = size;
            }
            
            forward(input) {
                const output = new Float32Array(input.length * 2);
                
                for (let k = 0; k < input.length; k++) {
                    let real = 0;
                    let imag = 0;
                    
                    for (let n = 0; n < input.length; n++) {
                        const angle = -2 * Math.PI * k * n / input.length;
                        real += input[n] * Math.cos(angle);
                        imag += input[n] * Math.sin(angle);
                    }
                    
                    output[k * 2] = real;
                    output[k * 2 + 1] = imag;
                }
                
                return output;
            }
        }

        // Auto-load on page load
        window.onload = function() {
            loadFile();
        };
    </script>
</body>
</html>